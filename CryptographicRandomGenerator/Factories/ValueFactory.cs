using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace CryptographicRandomGenerator.Factories
{
    public abstract class ValueFactory<T> where T:struct 
    {
        //TODO Consider static that essentially generates values and reads next into an enumerable that is returned
        protected int SizeOfT { get; }
        private int _buffer;
        private int Buffer
        {
            get { return _buffer; }
            set { _buffer = value < 0 ? 256 : value; }
        }
        protected byte[] RdmBytes { get; private set; }
        protected int Offset { get; private set; }
        protected ValueFactory(int buffer = 256)
        {
            Offset = 0;
            SizeOfT = Marshal.SizeOf(typeof(T));
            _buffer = buffer;
        }
        /// <summary>
        /// generates buffer of cryptographically strong random bytes as needed
        /// and creates random value of child class type from buffer
        /// </summary>
        public abstract T Next();
        /// <summary>
        /// Generates number of cryptographically strong random bytes required to make
        /// a given number of values of the child class type
        /// </summary>
        /// <param name="number">Number of Values to be made from generated byte array</param>
        public void GenertateValues(int number)
        {
            int byteNumber = number * SizeOfT;
            RNGCryptoServiceProvider r = new RNGCryptoServiceProvider();
            RdmBytes = new byte[byteNumber];
            r.GetBytes(RdmBytes);
        }

        protected void IncrementOffset()
        {
            Offset += SizeOfT;
        }

        protected void CheckBuffer()
        {
            if (Offset + _buffer - 1 > RdmBytes.Length)
            {
                GenertateValues(_buffer);
            }
        }
    }
}